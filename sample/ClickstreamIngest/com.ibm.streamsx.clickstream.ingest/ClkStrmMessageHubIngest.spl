namespace com.ibm.streamsx.clickstream.ingest;
/*
 * This little micro-service ingests sample Clickstream data 
 * provided by IBM DSX via messageHub 
 */
use com.ibm.streamsx.messagehub::* ;
use com.ibm.streamsx.json::* ;
use com.ibm.streamsx.spl.util.RuntimeTraceGateFilter::* ;

composite MessageHubIngest
{
	param
		expression<rstring> $messageHubTopic : getCompileTimeValue("messageHubTopic", "dsxClkStrm") ;
		expression<rstring> $exportKind : getCompileTimeValue("exportKind", "dsxClkStrmTupleStream") ;
	graph
	// one of the attribute must be "message"
		stream<rstring message> MessageHubClkStrm = MessageHubConsumer()
		{
			param
				topic : $messageHubTopic ;
		}

		stream<DSXClkStrm_T> TupleClkStrm = JSONToTuple(MessageHubClkStrm)
		{
			param
				ignoreParsingError : true ;
		}

		stream<DSXClkStrm_T> RunGatedClkStrm = RuntimeTraceGateFilter(TupleClkStrm)
		{
		}

		() as ExportClkStrm = Export(TupleClkStrm)
		{
			param
				properties : { kind = $exportKind } ;
		}

		// The following operator will have to the replaced with Object Storage in cloud deployment
		() as FileSinkClkStrm = FileSink(RunGatedClkStrm)
		{
			param
				hasDelayField : true ; // Add the time delay field for timed offline replay
				file : getApplicationDir() + "/dsxClkStrm_{localtime:%Y.%m.%d_%H.%M.%S}_" +
					".csv.gz" ;
				format : csv ;
				flush : 1000u ;
				tuplesPerFile : 1000000u ;
				closeMode : count ;
				compression : gzip ;
		}

		/*		
		/*   standalone testing only 
		() as PrintLnClkStm = Custom(TupleClkStrm as inputStream)
		{
			logic
				onTuple inputStream :
				{
					println((rstring) inputStream) ;
				}

		}
 		*/
}




